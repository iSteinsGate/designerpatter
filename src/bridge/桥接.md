# 桥接模式(创建型)

## 概念

>
>
>*将抽象部分与它的实现部分分离，使它们都可以独立地变化。*

设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：

- 第一种设计方案是为每一种形状都提供一套各种颜色的版本。

- 第二种设计方案是根据实际需要对形状和颜色进行组合

  

对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。

## 实现

我们有一个作为桥接实现的 *DrawAPI* 接口和实现了 *DrawAPI* 接口的实体类 *RedCircle*、*GreenCircle*。*Shape* 是一个抽象类，将使用 *DrawAPI* 的对象。*BridgePatternDemo*，我们的演示类使用 *Shape* 类来画出不同颜色的圆。

![UyUew6.png](https://s1.ax1x.com/2020/07/17/UyUew6.png)

例如：

假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：

![UywFSg.png](https://s1.ax1x.com/2020/07/17/UywFSg.png)

如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。

所以，桥接模式就是为了避免直接继承带来的子类爆炸。

**使用桥接模式**：

![UywMfU.png](https://s1.ax1x.com/2020/07/17/UywMfU.png)

客户端调用

```java
  RefinedCar car = new BossCar(new HybridEngine());
  car.driver();
  car = new TinyCar(new ElectricEngine());
  car.driver();
```

如果要增加一种引擎，只需要针对`Engine`派生一个新的子类，如果要增加一个品牌，只需要针对`RefinedCar`派生一个子类，任何`RefinedCar`的子类都可以和任何一种`Engine`自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。

## 与装饰模式区别

1. 桥接模式就是应用合成/聚合复用原则的模式，而装饰模式是使用继承方式的模式。所以区别之一就出来了，一个使用的是继承方式，另一个使用的却是合成方式。
2. 装饰模式是动态地添加一些额外功能的模式，也就是说装饰模式是适应新需求而添加新功能，并且不影响其他对象的一种模式；而桥接模式是适应变化维度的一种模式，它在于将对象的各个维度的变化都独立开来，使一些变化不受其他因素变化的影响
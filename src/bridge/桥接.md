# 桥接模式(创建型)

## 介绍

**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

**何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。

**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

**使用场景：** 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

## 案例一：

设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：

- 第一种设计方案是为每一种形状都提供一套各种颜色的版本。

- 第二种设计方案是根据实际需要对形状和颜色进行组合

  

对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。

**实现**

我们有一个作为桥接实现的 *DrawAPI* 接口和实现了 *DrawAPI* 接口的实体类 *RedCircle*、*GreenCircle*。*Shape* 是一个抽象类，将使用 *DrawAPI* 的对象。*BridgePatternDemo*，我们的演示类使用 *Shape* 类来画出不同颜色的圆。

![Ug8NPe.png](https://s1.ax1x.com/2020/07/18/Ug8NPe.png)

```java
Shape redCircle = new Circle(100,100, 10, new RedCircle());
redCircle.draw();
Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
greenCircle.draw();
```



## 案例二

假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：

![UywFSg.png](https://s1.ax1x.com/2020/07/17/UywFSg.png)

如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。

所以，桥接模式就是为了避免直接继承带来的子类爆炸。

**使用桥接模式**：

![UywMfU.png](https://s1.ax1x.com/2020/07/17/UywMfU.png)

![Ug1Gsx.png](https://s1.ax1x.com/2020/07/18/Ug1Gsx.png)

客户端调用

```java
  RefinedCar car = new BossCar(new HybridEngine());
  car.driver();
  car = new TinyCar(new ElectricEngine());
  car.driver();
```

如果要增加一种引擎，只需要针对`Engine`派生一个新的子类，如果要增加一个品牌，只需要针对`RefinedCar`派生一个子类，任何`RefinedCar`的子类都可以和任何一种`Engine`自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。

## **与装饰者模式的区别**

1. 装饰模式是动态地添加一些额外功能的模式，也就是说装饰模式是适应新需求而添加新功能，并且不影响其他对象的一种模式；而桥接模式是适应变化维度的一种模式，它在于将对象的各个维度的变化都独立开来，使一些变化不受其他因素变化的影响
2. 使用方式不同。装饰器是必须有一个核心功能，在核心功能外可以套其他的装饰功能，没有装饰功能也可以使用；而桥接模式是没有核心功能之分，是必须组合桥接起来才能使用的。